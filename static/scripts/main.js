// Generated by CoffeeScript 1.6.3
(function() {
  var Alert, BASE_URL, Chat, ChatForm, ChatLink, ChatMessage, ChatMessages, Dom, Footer, Input, Navbar, Noop, PEER_KEY, Root, Settings, Textarea, delay, generateUuid4, getSegments, mountNode, navbarItems, options, routes, sum,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Dom = React.DOM;

  delay = function(ms, fn) {
    return setTimeout(fn, ms);
  };

  getSegments = function() {
    var uri;
    uri = location.hash.slice(2);
    return uri.split("/");
  };

  generateUuid4 = function() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
      var r, v;
      r = Math.random() * 16 | 0;
      v = (c === "x" ? r : r & 0x3 | 0x8);
      return v.toString(16);
    });
  };

  sum = function(coll) {
    return _.reduce(coll, (function(a, x) {
      return a + x;
    }), 0);
  };

  PEER_KEY = "3wlgt1tsm69u23xr";

  BASE_URL = location.origin + location.pathname;

  Noop = React.createClass({
    displayName: "Noop",
    render: function() {
      return Dom.span(null);
    }
  });

  Input = React.createClass({
    displayName: "Input",
    render: function() {
      var defaultProps, idForDiv, props;
      defaultProps = {
        type: "text",
        className: "form-control"
      };
      props = _.extend(defaultProps, this.props);
      idForDiv = props.id;
      props.id = generateUuid4();
      return Dom.div({
        id: idForDiv,
        className: "form-group"
      }, Dom.label({
        htmlFor: props.id
      }, props.label), Dom.input(props));
    }
  });

  Textarea = React.createClass({
    displayName: "Textarea",
    render: function() {
      var defaultProps, props;
      defaultProps = {
        cols: 80,
        rows: 4,
        className: "form-control"
      };
      props = _.extend(defaultProps, this.props);
      return Dom.textarea(props);
    }
  });

  Navbar = React.createClass({
    displayName: "Navbar",
    render: function() {
      return Dom.nav({
        id: "navbar",
        className: "navbar navbar-default"
      }, Dom.div({
        className: "navbar-header"
      }, Dom.a({
        className: "navbar-brand"
      }, this.props.brandName)), Dom.ul({
        className: "nav navbar-nav"
      }, _.map(this.props.navbarItems, function(item) {
        var title, url;
        url = item[0], title = item[1];
        return Dom.li(null, Dom.a({
          href: "#" + url
        }, title));
      })));
    }
  });

  Footer = React.createClass({
    displayName: "Footer",
    render: function() {
      return Dom.div({
        id: "footer"
      }, Dom.p(null, Dom.a({
        href: "https://github.com/daGrevis/Hendrix"
      }, "Hendrix on GitHub")), Dom.p(null, Dom.a({
        href: "https://twitter.com/dagrevis"
      }, "Made by @daGrevis")));
    }
  });

  Alert = React.createClass({
    displayName: "Alert",
    render: function() {
      var defaultProps, props;
      defaultProps = {
        type: "success",
        className: "alert"
      };
      props = _.extend(defaultProps, this.props);
      props.className = "" + props.className + " alert-" + props.type;
      delete props.type;
      return Dom.div(props, this.props.children);
    }
  });

  ChatMessage = React.createClass({
    displayName: "ChatMessage",
    render: function() {
      var classNamesForLi, content;
      content = marked(this.props.content);
      classNamesForLi = ["media"];
      if (this.props.isNotice) {
        classNamesForLi.push("notice-message");
      }
      if (this.props.isRepeated) {
        classNamesForLi.push("repeated-message");
      }
      return Dom.li({
        className: classNamesForLi.join(" ")
      }, Dom.a({
        className: "pull-left avatar"
      }, Dom.img({
        width: 32,
        height: 32,
        src: "http://avatars.io/email/" + this.props.email + "?size=small",
        className: "media-object"
      })), Dom.div({
        className: "media-body"
      }, Dom.h4({
        className: "media-heading displayName"
      }, this.props.displayName), Dom.span({
        dangerouslySetInnerHTML: {
          __html: content
        }
      })));
    }
  });

  ChatMessages = React.createClass({
    displayName: "ChatMessages",
    componentDidUpdate: function() {
      var $chatMessages, height;
      $chatMessages = document.getElementById("chat-messages");
      $chatMessages.scrollTop = $chatMessages.scrollHeight;
      height = window.innerHeight - 480;
      return $chatMessages.style.height = "" + height + "px";
    },
    render: function() {
      var peerId,
        _this = this;
      return Dom.ul({
        id: "chat-messages",
        className: "media-list"
      }, peerId = false, _.map(this.props.messages, function(message) {
        var isRepeated, props;
        if (peerId === message.peerId) {
          isRepeated = true;
        } else {
          isRepeated = false;
        }
        peerId = message.peerId;
        props = {
          content: message.content,
          displayName: message.displayName,
          email: message.email,
          isNotice: message.isNotice,
          isRepeated: isRepeated
        };
        return ChatMessage(props);
      }));
    }
  });

  ChatForm = React.createClass({
    mixins: [React.addons.LinkedStateMixin],
    displayName: "ChatForm",
    getInitialState: function() {
      return {
        message: "",
        keysPressed: {
          "Shift": false,
          "Enter": false
        }
      };
    },
    render: function() {
      return Dom.form({
        id: "chat-form",
        onKeyDown: this.keyDown,
        onKeyUp: this.keyUp
      }, Textarea({
        id: "message",
        placeholder: "Type a message here...",
        valueLink: this.linkState("message"),
        readOnly: !this.props.channelActive
      }));
    },
    keyDown: function(event) {
      var keysPressed, message, _ref;
      if (_ref = event.key, __indexOf.call(_.keys(this.state.keysPressed), _ref) >= 0) {
        keysPressed = this.state.keysPressed;
        keysPressed[event.key] = true;
        this.setState({
          keysPressed: keysPressed
        });
        if (!keysPressed["Shift"] && keysPressed["Enter"]) {
          if (!this.state.message) {
            alert("You can't send nothing!");
            return;
          }
          message = {
            displayName: store.get("displayName"),
            email: store.get("email"),
            content: this.state.message
          };
          this.props.sendMessage(message);
          this.setState({
            message: ""
          });
          return event.preventDefault();
        }
      }
    },
    keyUp: function(event) {
      var keysPressed, _ref;
      if (_ref = event.key, __indexOf.call(_.keys(this.state.keysPressed), _ref) >= 0) {
        keysPressed = this.state.keysPressed;
        keysPressed[event.key] = false;
        return this.setState({
          keysPressed: keysPressed
        });
      }
    }
  });

  ChatLink = React.createClass({
    displayName: "ChatLink",
    render: function() {
      if (!this.props.peerIdForFounder) {
        return Noop();
      }
      return Input({
        id: "chat-link",
        label: "Chat Link",
        readOnly: true,
        value: this.getLink()
      });
    },
    getLink: function() {
      return "" + BASE_URL + "#/chat/" + this.props.peerIdForFounder;
    }
  });

  Chat = React.createClass({
    displayName: "Chat",
    getInitialState: function() {
      return {
        peerIdForFounder: null,
        messages: [],
        channelActive: false
      };
    },
    componentWillMount: function() {
      var isFounder, peerIdForFounder,
        _this = this;
      this.selfUnmount = false;
      peerIdForFounder = getSegments()[1];
      isFounder = peerIdForFounder == null;
      this.peer = new Peer({
        key: PEER_KEY
      });
      this.connections = [];
      this.peer.on("error", function(error) {
        console.log(error);
        return _this.props.addAlert({
          type: "danger"
        }, "Something went terribly wrong! See console.");
      });
      return this.peer.on("open", function(peerId) {
        var connection;
        _this.peerId = _this.peer.id;
        _this.setState({
          channelActive: true
        });
        if (isFounder) {
          _this.props.addAlert({
            type: "success"
          }, "You just created a channel! You are the founder.");
          peerIdForFounder = _this.peer.id;
          _this.setState({
            peerIdForFounder: peerIdForFounder
          });
          _this.peer.on("connection", function(connection) {
            connection.on("open", function() {
              var peerIds;
              if (_this.connections.length) {
                peerIds = _.map(_this.connections, function(connection) {
                  return connection.peer;
                });
                connection.send({
                  type: "newConnection",
                  peerIds: peerIds
                });
              }
              _this.connections.push(connection);
              _this.listenForMessage(connection);
              return _this.addNotice("Someone joined the channel...");
            });
            return connection.on("close", _this.connectionClose);
          });
        }
        if (!isFounder) {
          _this.props.addAlert({
            type: "success"
          }, "You just joined to an existing channel! You are a peer.");
          _this.setState({
            peerIdForFounder: peerIdForFounder
          });
          connection = _this.peer.connect(peerIdForFounder);
          connection.on("open", function() {
            _this.connections.push(connection);
            _this.listenForMessage(connection);
            connection.on("data", function(data) {
              if (data.type === "newConnection") {
                return _.forEach(data.peerIds, function(peerId) {
                  connection = _this.peer.connect(peerId);
                  return (function(connection) {
                    return connection.on("open", function() {
                      _this.connections.push(connection);
                      _this.listenForMessage(connection);
                      return connection.on("close", _this.connectionClose);
                    });
                  })(connection);
                });
              }
            });
            return connection.on("close", function() {
              if (_this.selfUnmount) {
                return;
              }
              _this.addNotice("Founder left the channel!");
              return _this.setState({
                channelActive: false
              });
            });
          });
          return _this.peer.on("connection", function(connection) {
            return connection.on("open", function() {
              _this.connections.push(connection);
              _this.listenForMessage(connection);
              _this.addNotice("Someone joined the channel...");
              return connection.on("close", _this.connectionClose);
            });
          });
        }
      });
    },
    componentWillUnmount: function() {
      this.selfUnmount = true;
      return this.peer.destroy();
    },
    render: function() {
      return Dom.div(null, ChatLink({
        peerIdForFounder: this.state.peerIdForFounder
      }), ChatMessages({
        messages: this.state.messages
      }), ChatForm({
        sendMessage: this.sendMessage,
        channelActive: this.state.channelActive
      }));
    },
    sendMessage: function(message) {
      var data, messages, newConnections,
        _this = this;
      messages = this.state.messages;
      message.peerId = this.peerId;
      messages.push(message);
      this.setState({
        messages: messages
      });
      data = {
        type: "message",
        message: message
      };
      newConnections = [];
      _.forEach(this.connections, function(connection) {
        if (connection.open) {
          newConnections.push(connection);
          return connection.send(data);
        }
      });
      return this.connections = newConnections;
    },
    listenForMessage: function(connection) {
      var _this = this;
      return connection.on("data", function(data) {
        var messages;
        if (data.type === "message") {
          messages = _this.state.messages;
          messages.push(data.message);
          return _this.setState({
            messages: messages
          });
        }
      });
    },
    connectionClose: function() {
      return this.addNotice("Someone left the channel...");
    },
    addNotice: function(content) {
      var notice_message;
      notice_message = {
        isNotice: true,
        content: content
      };
      return this.setState({
        messages: this.state.messages.concat(notice_message)
      });
    }
  });

  Settings = React.createClass({
    mixins: [React.addons.LinkedStateMixin],
    displayName: "Settings",
    getInitialState: function() {
      return {
        displayName: store.get("displayName"),
        email: store.get("email")
      };
    },
    render: function() {
      return Dom.form({
        onSubmit: this.save
      }, Input({
        id: "displayName",
        label: "Display Name",
        valueLink: this.linkState("displayName")
      }), Input({
        id: "email",
        label: "Email (for Gravatar)",
        valueLink: this.linkState("email")
      }), Dom.button({
        className: "btn btn-success",
        type: "submit"
      }, "Save"));
    },
    save: function(event) {
      event.preventDefault();
      if (this.state.displayName) {
        store.set("displayName", this.state.displayName);
      }
      if (this.state.email) {
        store.set("email", this.state.email);
      }
      return this.props.addAlert({
        type: "success"
      }, "Changes saved!");
    }
  });

  routes = [["/chat", Chat], [/chat\/.+/, Chat], ["/settings", Settings]];

  navbarItems = [["/chat", "Chat"], ["/settings", "Settings"]];

  Root = React.createClass({
    displayName: "Root",
    getInitialState: function() {
      return {
        currentComponent: Noop(),
        alert: Noop()
      };
    },
    componentWillMount: function() {
      return this.router = Router();
    },
    componentDidMount: function() {
      var _this = this;
      _.forEach(this.props.routes, function(route) {
        var component, url;
        url = route[0], component = route[1];
        return _this.router.on(url, function() {
          return _this.setState({
            currentComponent: component({
              router: _this.router,
              addAlert: _this.addAlert
            })
          });
        });
      });
      return this.router.init(this.props.defaultRoute);
    },
    render: function() {
      return Dom.div({
        className: "container"
      }, Navbar({
        brandName: this.props.brandName,
        navbarItems: this.props.navbarItems
      }), this.state.alert, this.state.currentComponent, Footer());
    },
    addAlert: function(props, children) {
      var _this = this;
      this.setState({
        alert: Alert(props, children)
      });
      return delay(this.props.alertDelay, function() {
        return _this.setState({
          alert: Noop()
        });
      });
    }
  });

  options = {
    routes: routes,
    defaultRoute: "/chat",
    brandName: "Hendrix",
    navbarItems: navbarItems,
    alertDelay: 4 * 1000
  };

  mountNode = document.getElementById("react");

  React.renderComponent(Root(options), mountNode);

}).call(this);
